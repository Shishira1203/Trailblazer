{"version":3,"sources":["algorithms/astar.js","components/Node.jsx","algorithms/dijkstra.js","algorithms/dfs.js","algorithms/bfs.js","shared/tb.jpeg","components/HeaderComponent.jsx","components/MainComponent.jsx","App.js","reportWebVitals.js","index.js"],"names":["shortestPathInOrderArray","Node","this","props","col","onMouseDown","onMouseEnter","onMouseUp","row","className","Component","Dijkstra","grid","startNode","finishNode","visitedNodesInOrder","distance","unvisitedNodes","nodes","node","push","getAllNodes","length","sortNodesByDistance","closestNode","shift","isWall","Infinity","isVisited","updateUnvisitedNeighbors","sort","A","B","unvisitedNeighbors","neighbors","filter","neighbor","getUnvisitedNeighbors","previousNode","Dfs","srow","scol","stack","x","pop","isFinish","isSafe","helper","Bfs","findGraphNode","list","i","heuristicEuclidean","node1","node2","d1","Math","abs","d2","sqrt","heuristicDiagonal","max","heuristicManhattan","neighborss","ret","y","Example","useState","isOpen","setIsOpen","disabled","Navbar","color","light","expand","NavbarBrand","src","tb","alt","width","height","NavbarToggler","onClick","Collapse","navbar","Nav","NavItem","Button","Astar","Reset","Trailblazer","state","mousePressed","toChange","S_NODE_ROW","S_NODE_COL","F_NODE_ROW","F_NODE_COL","start","finish","visitedCount","shortestPathCount","resetGrid","bind","visualizeDfs","visualizeBfs","visualizeAstar","visualizeDijkstra","currentRow","createNode","newGrid","slice","newNode","nxode","setState","getInitialGrid","change","ChangedNode","isStart","handleStart","handleFinish","getNewGridWithWallToggled","forceUpdate","nodesInShortestPathOrder","setTimeout","animateShortestPath","resetOnlyVisited","currentNode","unshift","getNodesInShortestPathOrder","animateDijkstra","animateDfs","animateBfs","heuristic","selectedheuristic","f","g","h","openList","closedList","lowInd","k","curr","splice","reverse","gScore","gScoreIsBest","animateAstar","map","rowIdx","nodeIdx","handleMouseDown","handleMouseEnter","handleMouseUp","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.8c1a2937.chunk.js","sourcesContent":["var shortestPathInOrderArray;\nexport function Astar(grid, startNode, finishNode,selectedheuristic) {\n    shortestPathInOrderArray = [startNode];\n    for (var x = 0; x < grid.length; x++) {\n        for (var y = 0; y < grid[x].length; y++) {\n            grid[x][y].f = 0;\n            grid[x][y].g = 0;\n            grid[x][y].h = 0;\n        }\n    }\n    const visitedNodesInOrder = [];\n    const openList = [], closedList = [];\n    openList.push(startNode);\n    visitedNodesInOrder.push(startNode);\n    while (openList.length) {\n        var lowInd = 0;\n        for (var k = 0; k < openList.length; k++){\n            if (openList[k].f < openList[lowInd].f) {\n                lowInd = k;\n            }\n        }\n        var currentNode = openList[lowInd];\n        if (currentNode.row === finishNode.row&&currentNode.col===finishNode.col) {\n            var curr = currentNode;\n            shortestPathInOrderArray.splice(0, shortestPathInOrderArray.length);\n            while (curr.previousNode) {\n                shortestPathInOrderArray.push(curr);\n                curr = curr.previousNode;\n            }\n            shortestPathInOrderArray.reverse();\n            shortestPathInOrderArray.unshift(startNode);\n            return visitedNodesInOrder;\n        }\n        openList.splice(lowInd, 1);\n        closedList.push(currentNode);\n        var neighbors = neighborss(grid, currentNode);\n\n        for (var i =0; i < neighbors.length; i++) {\n            var neighbor = neighbors[i];\n            if (findGraphNode(closedList,neighbor) || neighbor.isWall) {\n                continue;\n            }\n            var gScore = currentNode.g + 1;\n            var gScoreIsBest = false;\n\n            if (!findGraphNode(openList,neighbor)) {\n                gScoreIsBest = true;\n                if (selectedheuristic === \"Euclidean\") {\n                    neighbor.h = heuristicEuclidean(neighbor, finishNode);\n                }\n                else if (selectedheuristic === \"Manhattan\") {\n                    neighbor.h = heuristicManhattan(neighbor, finishNode);\n                }\n                else {\n                    neighbor.h = heuristicDiagonal(neighbor, finishNode);\n                }\n                openList.push(neighbor);\n                visitedNodesInOrder.push(neighbor);\n            }\n\n            else if (gScore < neighbor.g) {\n                gScoreIsBest = true;\n            }\n\n            if (gScoreIsBest) {\n                neighbor.previousNode = currentNode;\n                neighbor.g = gScore;\n                neighbor.f = neighbor.g + neighbor.h;\n            }\n        }\n    }\n    return [startNode];\n}\nexport function shortestPathInOrder() {\n    return shortestPathInOrderArray;\n}\nfunction findGraphNode(list, node) {\n    for (var i = 0; i < list.length; i++){\n        if (list[i] === node) return true;\n    }\n    return false;\n}\n\nfunction heuristicEuclidean(node1, node2) {\n    var d1 = Math.abs(node1.row - node2.row);\n    var d2 = Math.abs(node1.col - node2.col);\n    return Math.sqrt(d1*d1 + d2*d2);\n}\n\nfunction heuristicDiagonal(node1, node2) {\n    var d1 = Math.abs(node1.row - node2.row);\n    var d2 = Math.abs(node1.col - node2.col);\n    return Math.max(d1,d2);\n}\n\nfunction heuristicManhattan(node1, node2) {\n    var d1 = Math.abs(node1.row - node2.row);\n    var d2 = Math.abs(node1.col - node2.col);\n    return d1 + d2;\n}\n\nfunction neighborss(grid, node) {\n    var ret = [];\n    var x = node.row;\n    var y = node.col;\n\n    if (grid[x - 1] && grid[x - 1][y]) {\n        ret.push(grid[x - 1][y]);\n    }\n    if (grid[x + 1] && grid[x + 1][y]) {\n        ret.push(grid[x + 1][y]);\n    }\n    if (grid[x][y - 1] && grid[x][y - 1]) {\n        ret.push(grid[x][y - 1]);\n    }\n    if (grid[x][y + 1] && grid[x][y + 1]) {\n        ret.push(grid[x][y + 1]);\n    }\n    return ret;\n}","import React, { Component } from 'react';\nimport '../App.css';\nexport default class Node extends Component {\n    render() {\n        const {\n            col,\n            onMouseDown,\n            onMouseEnter,\n            onMouseUp,\n            row,\n            className\n        } = this.props;\n\n        return (\n            <div\n                className={className}\n                onMouseDown={() => onMouseDown(row, col)}\n                onMouseEnter={() => onMouseEnter(row, col)}\n                onMouseUp={() => onMouseUp()}></div>\n        );\n    }\n}","export function Dijkstra(grid, startNode, finishNode) {\n    const visitedNodesInOrder = [];\n    startNode.distance = 0;\n    const unvisitedNodes = getAllNodes(grid);\n    while (unvisitedNodes.length) {\n        sortNodesByDistance(unvisitedNodes);\n        \n        const closestNode = unvisitedNodes.shift();\n        if (closestNode.isWall) continue;\n\n        if (closestNode.distance === Infinity) return visitedNodesInOrder;\n\n        closestNode.isVisited = true;\n        visitedNodesInOrder.push(closestNode);\n\n        if (closestNode === finishNode) return visitedNodesInOrder;\n        updateUnvisitedNeighbors(closestNode, grid);\n    }\n}\n\nfunction sortNodesByDistance(unvisitedNodes) {\n    unvisitedNodes.sort((A, B) => A.distance - B.distance);\n}\n\nfunction updateUnvisitedNeighbors(node, grid) {\n    const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n    for (const neighbor of unvisitedNeighbors) {\n        neighbor.distance = node.distance + 1;\n        neighbor.previousNode = node;\n    }\n}\n\nfunction getUnvisitedNeighbors(node, grid) {\n    const neighbors = [];\n    const { col, row } = node;\n    if (row > 0) neighbors.push(grid[row - 1][col]);\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n    if (col > 0) neighbors.push(grid[row][col - 1]);\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n    return neighbors.filter(neighbor => !neighbor.isVisited);\n}\n\nfunction getAllNodes(grid) {\n    const nodes = [];\n    for (const row of grid) {\n        for (const node of row) {\n            nodes.push(node);\n        }\n    }\n    return nodes;\n}\n\nexport function getNodesInShortestPathOrder(finishNode) {\n    const nodesInShortestPathOrder = [];\n    let currentNode = finishNode;\n    while (currentNode !== null) {\n        nodesInShortestPathOrder.unshift(currentNode);\n        currentNode = currentNode.previousNode;\n    }\n    return nodesInShortestPathOrder;\n}","export function Dfs(grid, startNode) {\n    const visitedNodesInOrder = [];\n    helper(grid, startNode.row, startNode.col, visitedNodesInOrder);\n    return visitedNodesInOrder;\n}\nfunction isSafe(grid,srow,scol) {\n    return srow >= 0 && srow < grid.length && scol >= 0 && scol < grid[0].length && !grid[srow][scol].isVisited&&!grid[srow][scol].isWall;\n}\nfunction helper(grid, srow, scol, visitedNodesInOrder) {\n    const stack = [];\n    stack.push(grid[srow][scol]);\n    while (stack.length) {\n        const x = stack.pop();\n        if (x.isFinish) {\n            visitedNodesInOrder.push(x);\n            break;\n        }\n        visitedNodesInOrder.push(x);\n        x.isVisited = true;\n        if (isSafe(grid, x.row+1, x.col)) {\n            stack.push(grid[x.row+1][x.col]);\n        }\n        if (isSafe(grid, x.row, x.col - 1)) {\n            stack.push(grid[x.row][x.col - 1]);\n        }\n        if (isSafe(grid, x.row, x.col+1)) {\n            stack.push(grid[x.row][x.col+1]);\n        }\n        if (isSafe(grid, x.row-1, x.col)) {\n            stack.push(grid[x.row-1][x.col]);\n        }\n    }\n}","export function Bfs(grid, startNode, finishNode) {\n    const visitedNodesInOrder = [];\n    startNode.distance = 0;\n    const unvisitedNodes = getAllNodes(grid);\n    while (unvisitedNodes.length) {\n        sortNodesByDistance(unvisitedNodes);\n\n        const closestNode = unvisitedNodes.shift();\n        if (closestNode.isWall) continue;\n\n        if (closestNode.distance === Infinity) return visitedNodesInOrder;\n\n        closestNode.isVisited = true;\n        visitedNodesInOrder.push(closestNode);\n\n        if (closestNode === finishNode) return visitedNodesInOrder;\n        updateUnvisitedNeighbors(closestNode, grid);\n    }\n}\n\nfunction sortNodesByDistance(unvisitedNodes) {\n    unvisitedNodes.sort((A, B) => A.distance - B.distance);\n}\n\nfunction updateUnvisitedNeighbors(node, grid) {\n    const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n    for (const neighbor of unvisitedNeighbors) {\n        neighbor.distance = node.distance + 1;\n        neighbor.previousNode = node;\n    }\n}\n\nfunction getUnvisitedNeighbors(node, grid) {\n    const neighbors = [];\n    const { col, row } = node;\n    if (row > 0) neighbors.push(grid[row - 1][col]);\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n    if (col > 0) neighbors.push(grid[row][col - 1]);\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n    return neighbors.filter(neighbor => !neighbor.isVisited);\n}\n\nfunction getAllNodes(grid) {\n    const nodes = [];\n    for (const row of grid) {\n        for (const node of row) {\n            nodes.push(node);\n        }\n    }\n    return nodes;\n}","export default __webpack_public_path__ + \"static/media/tb.e5d7322e.jpeg\";","import React, { useState } from 'react';\nimport  tb from '../shared/tb.jpeg';\nimport {\n    Collapse,\n    Navbar,\n    NavbarToggler,\n    Nav,\n    NavItem,\n    Button,\n    NavbarBrand\n} from 'reactstrap';\nconst Example = (props) => {\n    const [isOpen, setIsOpen] = useState(false);\n    const disabled = props.disabled;\n    const toggle = () => setIsOpen(!isOpen);\n\n    return (\n        <div>\n            <Navbar color=\"dark\" light expand=\"md\">\n                <NavbarBrand className=\"text-white\"><img src={tb} alt=\"logo\" width=\"40\" height=\"40\"></img>Trailblazer</NavbarBrand>\n                <NavbarToggler onClick={toggle} />\n                <Collapse isOpen={isOpen} navbar>\n                    <Nav className=\"mr-auto\" navbar>\n                        <NavItem>\n                            <Button disabled={disabled} className=\"btn bg-transparent  text-white\" onClick={() => { props.Dijkstra(); }}>Dijkstra</Button>\n                        </NavItem>\n                        <NavItem>\n                            <Button disabled={disabled} className=\"btn bg-transparent  text-white\" onClick={() => { props.Dfs(); }}>Depth First Search</Button>\n                        </NavItem>\n                        <NavItem>\n                            <Button disabled={disabled} className=\"btn bg-transparent  text-white\" onClick={() => { props.Bfs(); }}>Breadth First Search</Button>\n                        </NavItem>\n                        <NavItem>\n                            <Button disabled={disabled} className=\"btn bg-transparent  text-white\" onClick={() => { props.Astar(\"Euclidean\"); }}>Astar Euclidean</Button>\n                        </NavItem>\n                        <NavItem>\n                            <Button disabled={disabled} className=\"btn bg-transparent  text-white\" onClick={() => { props.Astar(\"Manhattan\"); }}>Astar Manhattan</Button>\n                        </NavItem>\n                        <NavItem>\n                            <Button disabled={disabled} className=\"btn bg-transparent  text-white\" onClick={() => { props.Astar(\"Diagonal\"); }}>Astar Diagonal</Button>\n                        </NavItem>\n                        <NavItem>\n                            <Button disabled={disabled} className=\"btn bg-transparent  text-white\" onClick={() => props.Reset()}>Reset Grid</Button>\n                        </NavItem>\n                    </Nav>\n                </Collapse>\n            </Navbar>\n        </div>\n    );\n}\n\nexport default Example;","import React, { Component } from 'react';\nimport Node from './Node.jsx';\nimport '../App.css';\nimport { Dijkstra, getNodesInShortestPathOrder } from '../algorithms/dijkstra';\nimport { Dfs } from '../algorithms/dfs';\nimport { Bfs } from '../algorithms/bfs';\nimport { Astar, shortestPathInOrder } from '../algorithms/astar';\nimport Header from './HeaderComponent.jsx';\n\nexport default class Trailblazer extends Component {\n    constructor() {\n        super();\n        this.state = {\n            grid: [],\n            mousePressed: false,\n            toChange: null,\n            disabled: false,\n            S_NODE_ROW: 10,\n            S_NODE_COL: 15,\n            F_NODE_ROW: 10,\n            F_NODE_COL: 36,\n            start: false,\n            finish: false,\n            visitedCount: 0,\n            shortestPathCount:0\n        };\n        this.resetGrid = this.resetGrid.bind(this);\n        this.visualizeDfs = this.visualizeDfs.bind(this);\n        this.visualizeBfs = this.visualizeBfs.bind(this);\n        this.visualizeAstar = this.visualizeAstar.bind(this);\n        this.visualizeDijkstra = this.visualizeDijkstra.bind(this);\n    }\n\n    createNode(row, col) {\n        return {\n            col,\n            row,\n            className:'node',\n            distance: Infinity,\n            isVisited: false,\n            isWall: false,\n            previousNode: null,\n        };\n    };\n\n    getInitialGrid(){\n        const grid = [];\n        for (let row = 0; row < 24; row++) {\n            const currentRow = [];\n            for (let col = 0; col < 55; col++) {\n                currentRow.push(this.createNode(row, col));\n            }\n            grid.push(currentRow);\n        }\n        grid[this.state.S_NODE_ROW][this.state.S_NODE_COL].className = 'node node-start';\n        grid[this.state.F_NODE_ROW][this.state.F_NODE_COL].className = 'node node-finish';\n        return grid;\n    };\n\n    getNewGridWithWallToggled(row, col){\n        const newGrid = this.state.grid.slice();\n        const node = newGrid[row][col];\n        if (row === this.state.S_NODE_ROW && col === this.state.S_NODE_COL) return newGrid;\n        if (row === this.state.F_NODE_ROW && col === this.state.F_NODE_COL) return newGrid;\n        const newNode = {\n            ...node,\n            isWall: !node.isWall,\n            isVisited:false,\n            className: node.isWall?'node':'node node-wall',\n        };\n        newGrid[row][col] = newNode;\n        return newGrid;\n    };\n\n    resetOnlyVisited() {\n        const { toChange, grid } = this.state;\n        const newGrid = grid.slice();\n        if (toChange !== null) {\n            for (let i = 0; i < toChange.length; i++) {\n                const node = toChange[i];\n                if (node.row===this.state.S_NODE_ROW&&node.col===this.state.S_NODE_COL) {\n                    const nxode = grid[node.row][node.col];\n                    const newNode = {\n                        ...nxode,\n                        isVisited: false,\n                        className: 'node node-start'\n                    };\n                    newGrid[node.row][node.col] = newNode;\n                }\n                else if (node.row === this.state.F_NODE_ROW && node.col === this.state.F_NODE_COL) {\n                    const nxode = grid[node.row][node.col];\n                    const newNode = {\n                        ...nxode,\n                        isVisited: false,\n                        className: 'node node-finish'\n                    };\n                    newGrid[node.row][node.col] = newNode;\n                }\n                else if (grid[node.row][node.col].isWall){\n                    const nxode = grid[node.row][node.col];\n                    const newNode = {\n                        ...nxode,\n                        isVisited: false,\n                        isWall: true,\n                        className: 'node node-wall'\n                    };\n                    newGrid[node.row][node.col] = newNode;\n                }\n                else {\n                    const nxode = grid[node.row][node.col];\n                    const newNode = {\n                        ...nxode,\n                        isVisited: false,\n                        className: 'node'\n                    };\n                    newGrid[node.row][node.col] = newNode;\n                }\n            }\n            for (const row of grid) {\n                for (const node of row) {\n                    node.distance = Infinity;\n                }\n            }\n            \n        }\n        \n        this.setState({ grid: newGrid, toChange: null, visitedCount: 0, shortestPathCount: 0 });\n    }\n\n\n    resetGrid() {\n        const grid = this.getInitialGrid();\n        this.setState({ grid: grid, disabled: false,visitedCount:0,shortestPathCount:0});\n    }\n\n    componentDidMount() {\n        this.resetGrid();\n    }\n\n    handleStart(grid,row, col) {\n        const newGrid = grid.slice();\n        const change = newGrid[this.state.S_NODE_ROW][this.state.S_NODE_COL];\n        const ChangedNode = {\n            ...change,\n            isVisited:false,\n            isStart: false,\n            className:'node'\n        }\n        newGrid[this.state.S_NODE_ROW][this.state.S_NODE_COL] = ChangedNode;\n        const node = grid[row][col];\n        const newNode = {\n            ...node,\n            isVisited:false,\n            isStart: true,\n            className:'node node-start'\n        };\n        this.setState({ S_NODE_ROW: row, S_NODE_COL: col });\n        newGrid[row][col] = newNode;\n        return newGrid;\n    }\n\n    handleFinish(grid, row, col) {\n        const newGrid = grid.slice();\n        const change = newGrid[this.state.F_NODE_ROW][this.state.F_NODE_COL];\n        const ChangedNode = {\n            ...change,\n            isVisited:false,\n            isFinish: false,\n            className: 'node'\n        }\n        newGrid[this.state.F_NODE_ROW][this.state.F_NODE_COL] = ChangedNode;\n        const node = grid[row][col];\n        const newNode = {\n            ...node,\n            isFinish: true,\n            className:'node node-finish'\n        };\n        this.setState({ F_NODE_ROW: row, F_NODE_COL: col });\n        newGrid[row][col] = newNode;\n        return newGrid;\n    }\n\n    handleMouseDown(row, col) {\n        if (row===this.state.S_NODE_ROW&&col===this.state.S_NODE_COL) {\n            this.setState({ start: true });\n        }\n        if (row===this.state.F_NODE_ROW&&col===this.state.F_NODE_COL) {\n            this.setState({ finish: true });\n        }\n        const newGrid = this.state.start?this.handleStart(this.state.grid,row,col):this.state.finish?this.handleFinish(this.state.grid,row,col):this.getNewGridWithWallToggled(row, col);\n        this.setState({ grid: newGrid, mousePressed: true });\n    }\n\n    handleMouseEnter(row, col) {\n        if (!this.state.mousePressed) return;\n        const newGrid = this.state.start ? this.handleStart(this.state.grid, row, col) : this.state.finish ? this.handleFinish(this.state.grid, row, col) : this.getNewGridWithWallToggled( row, col);\n        this.setState({ grid: newGrid });\n    }\n\n    handleMouseUp() {\n        this.setState({ mousePressed: false, start: false, finish: false });\n        this.forceUpdate();\n    }\n\n    animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder) {\n        const newGrid = this.state.grid.slice();\n        for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n            if (i === visitedNodesInOrder.length) {\n                setTimeout(() => {\n                    this.animateShortestPath(nodesInShortestPathOrder);\n                }, 10 * i);\n                return;\n            }\n            setTimeout(() => {\n                const node = visitedNodesInOrder[i];\n                const nxode = newGrid[node.row][node.col];\n                const newNode = {\n                    ...nxode,\n                    previousNode: null,\n                    distance:Infinity,\n                    className: i===0?'node node-start-visited':i===visitedNodesInOrder.length-1?'node node-finish-visited':'node node-visited'\n                };\n                newGrid[node.row][node.col] = newNode;\n                this.setState({ grid: newGrid, visitedCount: this.state.visitedCount + 1 });\n            }, 10 * i);\n        }\n    }\n\n    animateShortestPath(nodesInShortestPathOrder) {\n        const newGrid = this.state.grid.slice();\n        for (let i = 0; i <= nodesInShortestPathOrder.length; i++) {\n            if (i === nodesInShortestPathOrder.length) {\n                setTimeout(() => {\n                    this.setState({ disabled: !this.state.disabled });\n                }, 50 * i);\n                return;\n            }\n            setTimeout(() => {\n                const node = nodesInShortestPathOrder[i];\n                const nxode = newGrid[node.row][node.col];\n                const newNode = {\n                    ...nxode,\n                    previousNode: null,\n                    distance:Infinity,\n                    className: i===0?'node node-start-shortest-path':i===nodesInShortestPathOrder.length-1?'node node-finish-shortest-path':'node node-shortest-path'\n                };\n                newGrid[node.row][node.col] = newNode;\n                this.setState({ grid: newGrid,shortestPathCount:this.state.shortestPathCount+1 });\n            }, 50 * i);\n        }\n    }\n\n    animateDfs(visitedNodesInOrder) {\n        const newGrid = this.state.grid.slice();\n        for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n            if (i === visitedNodesInOrder.length) {\n                setTimeout(() => {\n                    this.animateShortestPath(visitedNodesInOrder);\n                }, 10 * i);\n                return;\n            }\n            setTimeout(() => {\n                const node = visitedNodesInOrder[i];\n                const nxode = newGrid[node.row][node.col];\n                const newNode = {\n                    ...nxode,\n                    className: i === 0 ? 'node node-start-visited' : i === visitedNodesInOrder.length - 1 ? 'node node-finish-visited' : 'node node-visited'\n                };\n                newGrid[node.row][node.col] = newNode;\n                this.setState({ grid: newGrid,visitedCount:this.state.visitedCount+1 });\n            }, 10 * i);\n        }\n    }\n\n    visualizeDijkstra() {\n        const { grid } = this.state;\n        this.resetOnlyVisited();\n        const startNode = grid[this.state.S_NODE_ROW][this.state.S_NODE_COL];\n        const finishNode = grid[this.state.F_NODE_ROW][this.state.F_NODE_COL];\n        const visitedNodesInOrder = Dijkstra(grid, startNode, finishNode);\n        const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n        this.setState({ ...this.state, toChange: visitedNodesInOrder, visitedCount: 0, shortestPathCount: 0, disabled: !this.state.disabled, mousePressed: false});\n        this.animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder);\n    }\n\n    visualizeDfs() {\n        this.resetOnlyVisited();\n        const { grid } = this.state;\n        const startNode = grid[this.state.S_NODE_ROW][this.state.S_NODE_COL];\n        const finishNode = grid[this.state.F_NODE_ROW][this.state.F_NODE_COL];\n        const visitedNodesInOrder = Dfs(grid, startNode, finishNode);\n        this.setState({ ...this.state, toChange: visitedNodesInOrder, visitedCount: 0, shortestPathCount: 0, disabled: !this.state.disabled, mousePressed: false  });\n        this.animateDfs(visitedNodesInOrder);\n    }\n\n    animateBfs(visitedNodesInOrder) {\n        const newGrid = this.state.grid.slice();\n        for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n            if (i === visitedNodesInOrder.length) {\n                setTimeout(() => {\n                    this.animateShortestPath(visitedNodesInOrder);\n                }, 10 * i);\n                this.setState({ grid: newGrid });\n                return;\n            }\n            setTimeout(() => {\n                const node = visitedNodesInOrder[i];\n                const nxode = newGrid[node.row][node.col];\n                const newNode = {\n                    ...nxode,\n                    className: i === 0 ? 'node node-start-visited' : i === visitedNodesInOrder.length - 1 ? 'node node-finish-visited' : 'node node-visited'\n                };\n                newGrid[node.row][node.col] = newNode;\n                this.setState({ grid: newGrid, visitedCount: this.state.visitedCount + 1 });\n            }, 10 * i);\n        }\n    }\n\n    visualizeBfs() {\n        this.resetOnlyVisited();\n        const grid = this.state.grid;\n        const startNode = grid[this.state.S_NODE_ROW][this.state.S_NODE_COL];\n        const finishNode = grid[this.state.F_NODE_ROW][this.state.F_NODE_COL];\n        const visitedNodesInOrder = Bfs(grid, startNode, finishNode);\n        this.setState({ toChange: visitedNodesInOrder, visitedCount: 0, shortestPathCount: 0, disabled: !this.state.disabled, mousePressed: false });\n        this.animateBfs(visitedNodesInOrder);\n    }\n\n    animateAstar(visitedNodesInOrder, nodesInShortestPathOrder) {\n        const newGrid = this.state.grid.slice();\n        for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n            if (i === visitedNodesInOrder.length) {\n                setTimeout(() => {\n                    this.animateShortestPath(nodesInShortestPathOrder);\n                }, 10 * i);\n                return;\n            }\n            setTimeout(() => {\n                const node = visitedNodesInOrder[i];\n                const nxode = newGrid[node.row][node.col];\n                if (node.row === this.state.F_NODE_ROW && node.col === this.state.F_NODE_COL) {\n                    const newNode = {\n                        ...nxode,\n                        className: 'node node-finish-visited'\n                    };\n                    newGrid[node.row][node.col] = newNode;\n                    this.setState({ grid: newGrid, visitedCount: this.state.visitedCount + 1 });\n                }\n                else {\n                    const newNode = {\n                        ...nxode,\n                        className: i === 0 ? 'node node-start-visited' : 'node node-visited'\n                    };\n                    newGrid[node.row][node.col] = newNode;\n                    this.setState({ grid: newGrid, visitedCount: this.state.visitedCount + 1 });\n                }\n            }, 10 * i);\n        }\n    }\n\n\n    visualizeAstar(heuristic) {\n        this.resetOnlyVisited();\n        const grid = this.state.grid;\n        const startNode = grid[this.state.S_NODE_ROW][this.state.S_NODE_COL];\n        const finishNode = grid[this.state.F_NODE_ROW][this.state.F_NODE_COL];\n        const visitedNodesInOrder = Astar(grid, startNode, finishNode,heuristic);\n        const nodesInShortestPathOrder = shortestPathInOrder();\n        this.setState({ toChange: visitedNodesInOrder, visitedCount: 0, shortestPathCount: 0, disabled: !this.state.disabled, mousePressed: false  });\n        this.animateAstar(visitedNodesInOrder, nodesInShortestPathOrder);\n    }\n\n    render() {\n        const { grid, mousePressed,visitedCount,shortestPathCount,disabled } = this.state;\n        return (\n            <>\n                <Header Reset={this.resetGrid} Dijkstra={() => this.visualizeDijkstra()} Dfs={this.visualizeDfs} Bfs={this.visualizeBfs} Astar={(heuristic)=>this.visualizeAstar(heuristic)} disabled={this.state.disabled} />\n                <div className=\"container\">\n                    <div>Visited Nodes Count: {visitedCount}</div>\n                    <div>Shortest Path Nodes Count: {shortestPathCount}</div>\n                </div>\n                \n                <div className=\"grid\" disabled={disabled}>\n                    {\n                        grid.map((row, rowIdx) => {\n                            return (\n                                <div key={rowIdx} className=\"row\">\n                                    {\n                                        row.map((node, nodeIdx) => {\n                                            const { row, col, isWall,className } = node;\n                                            return (\n                                                <Node\n                                                    className={className}\n                                                    key={nodeIdx}\n                                                    col={col}\n                                                    isWall={isWall}\n                                                    mousePressed={mousePressed}\n                                                    onMouseDown={(row, col) => this.handleMouseDown(row, col)}\n                                                    onMouseEnter={(row, col) => this.handleMouseEnter(row, col)}\n                                                    onMouseUp={() => this.handleMouseUp()}\n                                                    row={row}>\n                                                </Node>\n                                            );\n                                        })}\n                                </div>\n                            );\n                        })}\n                </div>\n            </>\n        );\n    }\n}","import MainComponent from './components/MainComponent';\nimport 'bootstrap/dist/css/bootstrap.css';\nimport './index.css';\nimport './App.css';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <MainComponent/>\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport 'font-awesome/css/font-awesome.min.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}